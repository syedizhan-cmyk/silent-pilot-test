// AI-Powered Media Generation Service
import { generateContentWithGemini } from './gemini';

// Generate AI image using FREE services (Leonardo.ai primary)
export const generateAIImage = async (prompt, businessContext = '', style = 'professional') => {
  try {
    console.log('üé® Generating AI image with free services...');
    
    // Enhance prompt with Gemini (with fallback)
    let enhancedPrompt = prompt;
    
    // Try to use Gemini for prompt enhancement if available
    const geminiKey = process.env.REACT_APP_GEMINI_API_KEY;
    if (geminiKey && businessContext) {
      try {
        console.log('ü§ñ Using Gemini to enhance prompt...');
        const geminiPrompt = `Create a detailed, vivid image generation prompt.

User request: ${prompt}
Style: ${style}
Business context: ${businessContext}

Create ONE optimized image prompt (max 400 characters) that:
- Describes the visual scene in specific detail
- Includes the ${style} style naturally
- Incorporates relevant business branding/context
- Specifies lighting, composition, and mood
- Uses descriptive, evocative language
- Avoids generic descriptions

Return ONLY the prompt text, no explanations or quotes.`;

        enhancedPrompt = await generateContentWithGemini(geminiPrompt, 'image', businessContext);
        enhancedPrompt = enhancedPrompt.trim().replace(/^["']|["']$/g, '').substring(0, 1000);
        console.log('‚úÖ Gemini-enhanced prompt:', enhancedPrompt);
      } catch (geminiError) {
        console.log('‚ö†Ô∏è Gemini enhancement failed, using fallback:', geminiError.message);
        enhancedPrompt = `${prompt}, ${style} style, ${businessContext}, professional, high quality`;
      }
    } else {
      // Fallback: simple enhancement
      enhancedPrompt = businessContext 
        ? `${prompt}, ${style} style, ${businessContext}, professional, high quality`
        : `${prompt}, ${style} style, professional, high quality, detailed`;
    }
    
    console.log('Final enhanced prompt:', enhancedPrompt);
    
    // Add negative prompt for better quality
    const negativePrompt = 'blurry, low quality, distorted, watermark, text, signature, ugly, duplicate, morbid, mutilated, extra fingers, poorly drawn hands, poorly drawn face';
    
    // Try multiple services in order
    const errors = [];
    
    // 1. Try Pollinations AI (Completely FREE, good quality, no API key)
    try {
      console.log('Trying Pollinations AI (FREE - Stable Diffusion)...');
      
      // Use Pollinations with enhanced settings for better quality
      const pollinationsUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(enhancedPrompt)}?width=1024&height=1024&nologo=true&enhance=true&model=flux&seed=${Date.now()}`;
      
      // Wait a bit for Pollinations to generate the image (it generates on-the-fly)
      console.log('Waiting for Pollinations to generate image...');
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
      
      // Test if image loads by actually fetching it
      const testResponse = await fetch(pollinationsUrl);
      if (testResponse.ok && testResponse.headers.get('content-type')?.includes('image')) {
        console.log('‚úÖ Image generated with Pollinations AI');
        return {
          success: true,
          imageUrl: pollinationsUrl,
          prompt: prompt,
          enhancedPrompt: enhancedPrompt,
          note: 'Image generated by Pollinations AI (FREE - Flux Model)',
          service: 'Pollinations AI (Flux) üé®',
          downloadable: true
        };
      }
    } catch (pollinationsError) {
      errors.push('Pollinations AI: ' + pollinationsError.message);
      console.log('Pollinations AI failed, trying next...');
    }
    
    // 2. Try DeepAI as backup (lower quality but works)
    const deepaiKey = process.env.REACT_APP_DEEPAI_API_KEY;
    if (deepaiKey) {
      try {
        console.log('Trying DeepAI (backup)...');
        
        // Try the Stable Diffusion endpoint instead of basic text2img
        const formData = new FormData();
        formData.append('text', enhancedPrompt);
        
        const response = await fetch('https://api.deepai.org/api/stable-diffusion', {
          method: 'POST',
          headers: {
            'api-key': deepaiKey
          },
          body: formData
        });
        
        if (response.ok) {
          const data = await response.json();
          if (data.output_url) {
            console.log('‚úÖ Image generated with DeepAI');
            return {
              success: true,
              imageUrl: data.output_url,
              prompt: prompt,
              enhancedPrompt: enhancedPrompt,
              note: 'Image generated by DeepAI (Stable Diffusion)',
              service: 'DeepAI (Stable Diffusion)',
              downloadable: true
            };
          }
        }
      } catch (deepaiError) {
        errors.push('DeepAI: ' + deepaiError.message);
        console.log('DeepAI failed, trying next...', deepaiError);
      }
    }
    
    // 3. Try Leonardo.ai (FREE - 150 tokens/day, BEST quality)
    const leonardoKey = process.env.REACT_APP_LEONARDO_API_KEY;
    if (leonardoKey) {
      try {
        console.log('Trying Leonardo.ai (FREE - High Quality)...');
        
        // Step 1: Create generation
        const response = await fetch('https://cloud.leonardo.ai/api/rest/v1/generations', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${leonardoKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt: enhancedPrompt,
            negative_prompt: negativePrompt,
            modelId: '6bef9f1b-29cb-40c7-b9df-32b51c1f67d3', // Leonardo Phoenix (best quality)
            width: 1024,
            height: 1024,
            num_images: 1,
            guidance_scale: 7,
            sd_version: 'PHOENIX',
            presetStyle: style === 'professional' ? 'CINEMATIC' : 
                        style === 'creative' ? 'CREATIVE' : 
                        style === 'realistic' ? 'STOCK_PHOTO' : 'GENERAL'
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          const generationId = data.sdGenerationJob.generationId;
          
          // Step 2: Poll for completion
          console.log('Waiting for image generation...');
          let imageUrl = null;
          let attempts = 0;
          const maxAttempts = 30;
          
          while (!imageUrl && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
            
            const checkResponse = await fetch(
              `https://cloud.leonardo.ai/api/rest/v1/generations/${generationId}`,
              {
                headers: { 'Authorization': `Bearer ${leonardoKey}` }
              }
            );
            
            if (checkResponse.ok) {
              const checkData = await checkResponse.json();
              if (checkData.generations_by_pk?.status === 'COMPLETE' && 
                  checkData.generations_by_pk?.generated_images?.length > 0) {
                imageUrl = checkData.generations_by_pk.generated_images[0].url;
              }
            }
            attempts++;
          }
          
          if (imageUrl) {
            console.log('‚úÖ Image generated with Leonardo.ai');
            return {
              success: true,
              imageUrl: imageUrl,
              prompt: prompt,
              enhancedPrompt: enhancedPrompt,
              note: 'Image generated by Leonardo.ai (FREE - High Quality)',
              service: 'Leonardo.ai ‚≠ê',
              downloadable: true
            };
          }
        } else {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Leonardo.ai generation failed');
        }
      } catch (leonardoError) {
        errors.push('Leonardo.ai: ' + leonardoError.message);
        console.log('Leonardo.ai failed, trying next...', leonardoError);
      }
    } else {
      errors.push('Leonardo.ai: No API key found (add REACT_APP_LEONARDO_API_KEY to .env)');
      console.log('Leonardo.ai API key not found, trying other services...');
    }
    
    // Try other FREE services as fallbacks
    const errors2 = [];
    
    // 4. Try Hugging Face Inference API (FREE with rate limits)
    try {
      console.log('Trying Hugging Face (FREE)...');
      const hfResponse = await fetch(
        "https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-xl-base-1.0",
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ inputs: enhancedPrompt })
        }
      );
      
      if (hfResponse.ok) {
        const blob = await hfResponse.blob();
        const imageUrl = URL.createObjectURL(blob);
        console.log('‚úÖ Image generated with Hugging Face');
        return {
          success: true,
          imageUrl: imageUrl,
          prompt: prompt,
          enhancedPrompt: enhancedPrompt,
          note: 'Image generated by Hugging Face (FREE)',
          service: 'Hugging Face',
          downloadable: true,
          isBlob: true
        };
      }
    } catch (hfError) {
      errors.push('Hugging Face: ' + hfError.message);
      errors2.push('Hugging Face: ' + hfError.message);
      console.log('Hugging Face failed, trying next...');
    }
    
    // 5. Fallback: Use stock photo services
    console.log('Using stock photo service as fallback...');
    const placeholderServices = [
      `https://source.unsplash.com/1024x1024/?${encodeURIComponent(prompt.replace(/[^a-zA-Z0-9\s]/g, '').split(' ').slice(0, 3).join(','))}`,
      `https://picsum.photos/seed/${encodeURIComponent(prompt.substring(0, 20))}/1024/1024`,
    ];
    
    const allErrors = [...errors, ...errors2];
    
    return {
      success: true,
      imageUrl: placeholderServices[0],
      alternativeUrls: placeholderServices,
      prompt: prompt,
      enhancedPrompt: enhancedPrompt,
      note: 'Using stock photo. Add Leonardo.ai API key for FREE high-quality AI images!',
      service: 'Unsplash Stock Photos',
      downloadable: true,
      errors: allErrors,
      recommendation: 'Get FREE Leonardo.ai account at https://leonardo.ai/ - 150 tokens/day (30 images) with much better quality!'
    };
    
  } catch (error) {
    console.error('Image generation error:', error);
    throw error;
  }
};

// Alternative: Generate with Replicate (requires free API key)
export const generateImageWithReplicate = async (prompt, style = 'professional') => {
  const replicateKey = process.env.REACT_APP_REPLICATE_API_KEY;
  
  if (!replicateKey) {
    throw new Error('Replicate API key not found. Get one free at https://replicate.com');
  }
  
  try {
    const response = await fetch('https://api.replicate.com/v1/predictions', {
      method: 'POST',
      headers: {
        'Authorization': `Token ${replicateKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        version: 'stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b',
        input: {
          prompt: `${prompt}, ${style} style, high quality, detailed`,
          negative_prompt: 'blurry, low quality, distorted, watermark',
          width: 1024,
          height: 1024
        }
      })
    });
    
    const prediction = await response.json();
    
    // Poll for completion
    let result = prediction;
    while (result.status !== 'succeeded' && result.status !== 'failed') {
      await new Promise(resolve => setTimeout(resolve, 1000));
      const pollResponse = await fetch(`https://api.replicate.com/v1/predictions/${result.id}`, {
        headers: { 'Authorization': `Token ${replicateKey}` }
      });
      result = await pollResponse.json();
    }
    
    if (result.status === 'succeeded') {
      return {
        success: true,
        imageUrl: result.output[0],
        note: 'Image generated by Replicate (Stable Diffusion XL)',
        service: 'Replicate',
        downloadable: true
      };
    }
    
    throw new Error('Replicate generation failed');
  } catch (error) {
    throw error;
  }
};

// Generate infographic content structure
export const generateInfographicContent = async (topic, businessContext = '') => {
  try {
    console.log('üìä Generating infographic content...');
    
    const prompt = `Create a detailed infographic content structure about: ${topic}

Generate the following in a clear, organized format:

TITLE: [Catchy, attention-grabbing title - max 10 words]

SUBTITLE: [Brief description of what the infographic covers]

DATA POINTS (5-7 key statistics):
1. [Statistic] - [Description/Context] - Icon: [emoji]
2. [Statistic] - [Description/Context] - Icon: [emoji]
(continue for 5-7 points)

COLOR SCHEME:
Primary: [hex color]
Secondary: [hex color]
Accent: [hex color]

LAYOUT RECOMMENDATION: [vertical/horizontal/circular with reasoning]

DESIGN TIPS:
- [Tip 1]
- [Tip 2]
- [Tip 3]

Make it visually engaging, data-driven, and easy to understand.`;

    const response = await generateContentWithGemini(prompt, 'infographic', businessContext);
    
    return {
      success: true,
      content: response,
      rawText: response
    };
  } catch (error) {
    console.error('Infographic generation error:', error);
    throw error;
  }
};

// Generate video script for reels/TikTok
export const generateVideoScript = async (topic, duration = 30, businessContext = '') => {
  try {
    console.log('üé¨ Generating video script...');
    
    const prompt = `Create a ${duration}-second video script for TikTok/Reels about: ${topic}

Requirements:
- Hook viewers in first 3 seconds
- Include scene-by-scene breakdown
- Add text overlay suggestions
- Include trending audio/music suggestions
- Call-to-action at the end

Format:
HOOK (0-3s): [Opening line that grabs attention]
SCENE 1 (3-10s): [Visual + Text Overlay + Voiceover]
SCENE 2 (10-20s): [Visual + Text Overlay + Voiceover]
SCENE 3 (20-${duration}s): [Visual + Text Overlay + CTA]

MUSIC: [Suggested trending audio]
HASHTAGS: [5-10 relevant hashtags]`;

    const script = await generateContentWithGemini(prompt, 'video', businessContext);
    
    return {
      success: true,
      script: script,
      duration: duration,
      platform: 'reels/tiktok'
    };
  } catch (error) {
    console.error('Video script generation error:', error);
    throw error;
  }
};

// Generate carousel post content
export const generateCarouselContent = async (topic, slides = 5, businessContext = '') => {
  try {
    console.log('üì± Generating carousel content...');
    
    const prompt = `Create a ${slides}-slide Instagram/LinkedIn carousel about: ${topic}

For each slide provide:
- Slide number
- Main headline (bold, attention-grabbing)
- Supporting text (2-3 lines max)
- Visual suggestion (what image/graphic to use)
- Design tips (layout, colors, fonts)

Also include:
- Carousel caption
- Hashtags
- Call-to-action

Make it engaging, valuable, and shareable.`;

    const content = await generateContentWithGemini(prompt, 'carousel', businessContext);
    
    return {
      success: true,
      content: content,
      slideCount: slides
    };
  } catch (error) {
    console.error('Carousel generation error:', error);
    throw error;
  }
};

// Generate blog post outline
export const generateBlogOutline = async (topic, targetLength = 'medium', businessContext = '') => {
  try {
    console.log('üìù Generating blog outline...');
    
    const wordCount = {
      short: '800-1200',
      medium: '1500-2000',
      long: '2500-3500'
    };
    
    const prompt = `Create a detailed blog post outline about: ${topic}

Target length: ${wordCount[targetLength]} words

Include:
1. SEO-optimized title (60 characters max)
2. Meta description (155 characters max)
3. Introduction hook
4. 5-7 main sections with:
   - Section heading
   - Key points to cover
   - Supporting examples/data
5. Conclusion with CTA
6. Internal linking suggestions
7. 10 relevant keywords for SEO

Make it comprehensive and actionable.`;

    const outline = await generateContentWithGemini(prompt, 'blog', businessContext);
    
    return {
      success: true,
      outline: outline,
      targetLength: targetLength
    };
  } catch (error) {
    console.error('Blog outline generation error:', error);
    throw error;
  }
};

// Generate email newsletter content
export const generateNewsletterContent = async (topic, sections = 3, businessContext = '') => {
  try {
    console.log('üìß Generating newsletter content...');
    
    const prompt = `Create an engaging email newsletter about: ${topic}

Structure:
1. Subject line (compelling, 50 characters max)
2. Preview text (40 characters)
3. Opening paragraph (personalized greeting + hook)
4. ${sections} main sections with:
   - Section headline
   - Content (2-3 paragraphs)
   - Relevant link or CTA
5. Closing with clear call-to-action
6. P.S. (additional value or urgency)

Tone: Conversational yet professional
Goal: High open and click-through rates`;

    const newsletter = await generateContentWithGemini(prompt, 'email', businessContext);
    
    return {
      success: true,
      content: newsletter,
      sections: sections
    };
  } catch (error) {
    console.error('Newsletter generation error:', error);
    throw error;
  }
};

// Generate ad copy for various platforms
export const generateAdCopy = async (product, platform = 'facebook', adGoal = 'conversions', businessContext = '') => {
  try {
    console.log('üí∞ Generating ad copy...');
    
    const platformSpecs = {
      facebook: 'Facebook/Instagram Ads (Primary text: 125 chars, Headline: 40 chars, Description: 30 chars)',
      google: 'Google Ads (3 headlines: 30 chars each, 2 descriptions: 90 chars each)',
      linkedin: 'LinkedIn Ads (Headline: 70 chars, Description: 150 chars)',
      twitter: 'Twitter Ads (Tweet: 280 chars including link)'
    };
    
    const prompt = `Create ${platform} ad copy for: ${product}

Platform specs: ${platformSpecs[platform]}
Ad goal: ${adGoal}

Generate:
1. 3 headline variations (A/B/C test)
2. 3 primary text variations
3. 2 description variations
4. Call-to-action button text
5. Targeting suggestions (audience interests, demographics)
6. Budget recommendations

Make it persuasive, benefit-focused, and conversion-optimized.`;

    const adCopy = await generateContentWithGemini(prompt, 'ad', businessContext);
    
    return {
      success: true,
      copy: adCopy,
      platform: platform,
      goal: adGoal
    };
  } catch (error) {
    console.error('Ad copy generation error:', error);
    throw error;
  }
};

// Batch generate content for content calendar
export const generateContentBatch = async (numberOfPosts, platforms, theme, businessContext = '') => {
  try {
    console.log('üìÖ Generating content batch...');
    
    const prompt = `Create ${numberOfPosts} social media post ideas for the following platforms: ${platforms.join(', ')}

Theme: ${theme}

For each post provide:
1. Platform (which platform it's for)
2. Post type (carousel, single image, video, text, etc.)
3. Caption/content (complete, ready-to-post)
4. Best time to post (day and time)
5. Hashtags
6. Visual description (what image/video to create)

Ensure variety in post types and engagement tactics across the batch.
Create a cohesive content strategy that tells a story throughout the week.`;

    const batch = await generateContentWithGemini(prompt, 'batch', businessContext);
    
    return {
      success: true,
      content: batch,
      count: numberOfPosts,
      platforms: platforms
    };
  } catch (error) {
    console.error('Batch generation error:', error);
    throw error;
  }
};

// Content repurposing - turn one piece into multiple formats
export const repurposeContent = async (originalContent, targetFormats, businessContext = '') => {
  try {
    console.log('‚ôªÔ∏è Repurposing content...');
    
    const prompt = `Take this content and repurpose it for the following formats: ${targetFormats.join(', ')}

Original content:
${originalContent}

For each target format, create:
- Platform-optimized version
- Adapted length and style
- Appropriate hashtags/keywords
- Visual suggestions

Maintain the core message while optimizing for each platform's best practices.`;

    const repurposed = await generateContentWithGemini(prompt, 'repurpose', businessContext);
    
    return {
      success: true,
      content: repurposed,
      formats: targetFormats
    };
  } catch (error) {
    console.error('Content repurposing error:', error);
    throw error;
  }
};